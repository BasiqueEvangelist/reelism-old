const path = require("path");
const fs = require("fs");
const pathEx = require("./pathExtra");

module.exports = function (packinfo) {

    const startTsMs = Date.now();

    console.log(packinfo);
    if (!fs.existsSync(packinfo.basedOn)) {
        console.log("Based on what? Couldn't find path.");
        process.exit(1);
    }

    const baseFiles = pathEx.walkDir(packinfo.basedOn + "/data");
    const outPath = path.join("out", path.basename(process.cwd()));
    pathEx.removeDir("out");
    fs.mkdirSync(outPath, { recursive: true });
    fs.writeFileSync(path.join("out", "!!!warning.txt"),
        "This folder is generated by a tool.\n" +
        "All edits will be rolled back on rebuild.");



    console.log(`Prepared for processing in ${Date.now() - startTsMs}ms`);

    for (const file of baseFiles) {
        const newFileName = file.substring(packinfo.basedOn.length)
        try {
            if (path.extname(file) != ".json")
                continue;

            const newFilePath = path.join(outPath, newFileName);
            const origData = fs.readFileSync(file);

            const transformed = packinfo.pipeline(JSON.parse(origData));
            const transformedString = JSON.stringify(transformed, null, 1);

            if (JSON.stringify(JSON.parse(origData), null, 1) == transformedString)
                continue;

            console.log(newFileName);


            pathEx.createPath(newFilePath);
            fs.writeFileSync(newFilePath, transformedString, { encoding: "UTF-8" });
        }
        catch (ex) {
            console.log(`Error when processing ${newFileName}! Skipping;\n` + ex);
            //process.exit(1);
        }
    }

    console.log(`Processed in ${Date.now() - startTsMs}ms`)

    fs.copyFileSync("pack.mcmeta", path.join(outPath, "pack.mcmeta"));

    pathEx.copyDir("data", path.join(outPath, "data"));

    console.log(`Done in ${Date.now() - startTsMs}ms`)
}